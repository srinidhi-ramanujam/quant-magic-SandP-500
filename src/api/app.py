"""FastAPI entrypoint for Quant Magic."""

from __future__ import annotations

from functools import lru_cache
from typing import Any, Dict, Optional

from fastapi import Depends, FastAPI
from pydantic import BaseModel, Field

from src.models import FormattedResponse, QueryRequest
from src.services import QueryService, QueryServiceResult


_DEBUG_SENTINEL = object()


class QueryResponseModel(BaseModel):
    """Shape of responses returned by the query endpoint."""

    answer: str = Field(
        ..., description="Natural language answer generated by the pipeline."
    )
    success: bool = Field(
        ..., description="Indicates whether the pipeline completed successfully."
    )
    sql: Optional[str] = Field(
        default=None, description="SQL executed for the question (if available)."
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Telemetry, timing, and contextual metadata about the request.",
    )
    sources: Optional[list[str]] = Field(
        default=None, description="Underlying data sources referenced."
    )
    debug: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Debug artefacts when debug mode is enabled.",
    )
    error: Optional[str] = Field(
        default=None,
        description="Pipeline error message when success is False.",
    )

    @classmethod
    def from_service_result(
        cls,
        result: QueryServiceResult,
        response: FormattedResponse,
        *,
        debug: Any = _DEBUG_SENTINEL,
    ) -> "QueryResponseModel":
        """Translate service result into API response payload."""

        metadata = dict(response.metadata or {})
        metadata.setdefault("request_id", result.context.request_id)
        metadata.setdefault("total_time_seconds", round(result.context.elapsed(), 4))
        metadata["component_timings"] = result.context.component_timings

        if result.query_result:
            metadata.setdefault("row_count", result.query_result.row_count)

        return cls(
            answer=response.answer,
            success=response.success,
            sql=result.query_result.sql_executed if result.query_result else None,
            metadata=metadata,
            sources=response.sources or None,
            debug=response.debug_info if debug is _DEBUG_SENTINEL else debug,
            error=response.error,
        )


app = FastAPI(
    title="Quant Magic API",
    description="Natural language to SQL pipeline over S&P 500 financial data.",
    version="0.1.0",
)


@lru_cache(maxsize=1)
def get_cached_query_service() -> QueryService:
    """Ensure a singleton QueryService for the API lifespan."""
    return QueryService()


def get_query_service() -> QueryService:
    """FastAPI dependency for retrieving the query service."""
    return get_cached_query_service()


@app.get("/health", tags=["system"])
async def healthcheck() -> Dict[str, str]:
    """Simple health endpoint for readiness probes."""
    return {"status": "ok"}


@app.post("/query", response_model=QueryResponseModel, tags=["query"])
async def run_query(
    request: QueryRequest, service: QueryService = Depends(get_query_service)
) -> QueryResponseModel:
    """Execute the core pipeline via HTTP."""

    result = service.run(request.question, debug_mode=request.debug_mode)
    response = result.response

    debug_payload = response.debug_info if request.debug_mode else None
    return QueryResponseModel.from_service_result(result, response, debug=debug_payload)


@app.on_event("shutdown")
def _shutdown() -> None:  # pragma: no cover - FastAPI lifecycle hook
    """Close resources when the application exits."""
    get_cached_query_service().close()


__all__ = ["app", "get_query_service"]
